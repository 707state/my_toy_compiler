!_TAG_EXTRA_DESCRIPTION	anonymous	/Include tags for non-named objects like lambda/
!_TAG_EXTRA_DESCRIPTION	fileScope	/Include tags of file scope/
!_TAG_EXTRA_DESCRIPTION	pseudo	/Include pseudo tags/
!_TAG_EXTRA_DESCRIPTION	subparser	/Include tags generated by subparsers/
!_TAG_FIELD_DESCRIPTION	epoch	/the last modified time of the input file (only for F\/file kind tag)/
!_TAG_FIELD_DESCRIPTION	file	/File-restricted scoping/
!_TAG_FIELD_DESCRIPTION	input	/input file/
!_TAG_FIELD_DESCRIPTION	name	/tag name/
!_TAG_FIELD_DESCRIPTION	pattern	/pattern/
!_TAG_FIELD_DESCRIPTION	typeref	/Type and name of a variable or typedef/
!_TAG_FIELD_DESCRIPTION!C++	name	/aliased names/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_KIND_DESCRIPTION!C++	c,class	/classes/
!_TAG_KIND_DESCRIPTION!C++	d,macro	/macro definitions/
!_TAG_KIND_DESCRIPTION!C++	e,enumerator	/enumerators (values inside an enumeration)/
!_TAG_KIND_DESCRIPTION!C++	f,function	/function definitions/
!_TAG_KIND_DESCRIPTION!C++	g,enum	/enumeration names/
!_TAG_KIND_DESCRIPTION!C++	h,header	/included header files/
!_TAG_KIND_DESCRIPTION!C++	m,member	/class, struct, and union members/
!_TAG_KIND_DESCRIPTION!C++	n,namespace	/namespaces/
!_TAG_KIND_DESCRIPTION!C++	s,struct	/structure names/
!_TAG_KIND_DESCRIPTION!C++	t,typedef	/typedefs/
!_TAG_KIND_DESCRIPTION!C++	u,union	/union names/
!_TAG_KIND_DESCRIPTION!C++	v,variable	/variable definitions/
!_TAG_KIND_DESCRIPTION!JSON	a,array	/arrays/
!_TAG_KIND_DESCRIPTION!JSON	b,boolean	/booleans/
!_TAG_KIND_DESCRIPTION!JSON	n,number	/numbers/
!_TAG_KIND_DESCRIPTION!JSON	o,object	/objects/
!_TAG_KIND_DESCRIPTION!JSON	s,string	/strings/
!_TAG_KIND_DESCRIPTION!JSON	z,null	/nulls/
!_TAG_KIND_DESCRIPTION!LEX	c,cond	/start or exclusive condition/
!_TAG_KIND_DESCRIPTION!LEX	r,regex	/named regular expression/
!_TAG_KIND_DESCRIPTION!Make	I,makefile	/makefiles/
!_TAG_KIND_DESCRIPTION!Make	m,macro	/macros/
!_TAG_KIND_DESCRIPTION!Make	t,target	/targets/
!_TAG_KIND_DESCRIPTION!Markdown	S,subsection	/level 2 sections/
!_TAG_KIND_DESCRIPTION!Markdown	T,l4subsection	/level 4 sections/
!_TAG_KIND_DESCRIPTION!Markdown	c,chapter	/chapters/
!_TAG_KIND_DESCRIPTION!Markdown	n,footnote	/footnotes/
!_TAG_KIND_DESCRIPTION!Markdown	s,section	/sections/
!_TAG_KIND_DESCRIPTION!Markdown	t,subsubsection	/level 3 sections/
!_TAG_KIND_DESCRIPTION!Markdown	u,l5subsection	/level 5 sections/
!_TAG_KIND_DESCRIPTION!YACC	l,label	/labels/
!_TAG_KIND_DESCRIPTION!YACC	t,token	/tokens/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_OUTPUT_VERSION	0.0	/current.age/
!_TAG_PARSER_VERSION!C++	0.0	/current.age/
!_TAG_PARSER_VERSION!JSON	0.0	/current.age/
!_TAG_PARSER_VERSION!LEX	0.0	/current.age/
!_TAG_PARSER_VERSION!Make	0.0	/current.age/
!_TAG_PARSER_VERSION!Markdown	0.0	/current.age/
!_TAG_PARSER_VERSION!YACC	0.0	/current.age/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/sgj/codes/fy/my_toy_compiler/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	6.0.0	//
!_TAG_ROLE_DESCRIPTION!C++!header	local	/local header/
!_TAG_ROLE_DESCRIPTION!C++!header	system	/system header/
!_TAG_ROLE_DESCRIPTION!C++!macro	undef	/undefined/
!_TAG_ROLE_DESCRIPTION!Make!makefile	included	/included/
!_TAG_ROLE_DESCRIPTION!Make!makefile	optional	/optionally included/
%.o	Makefile	/^%.o: %.cpp$/;"	t
0	compile_commands.json	/^   "clang++",$/;"	s	array:0.arguments
0	compile_commands.json	/^   "clang++",$/;"	s	array:1.arguments
0	compile_commands.json	/^   "clang++",$/;"	s	array:2.arguments
0	compile_commands.json	/^   "clang++",$/;"	s	array:3.arguments
0	compile_commands.json	/^   "clang++",$/;"	s	array:4.arguments
0	compile_commands.json	/^ {$/;"	o
1	compile_commands.json	/^   "-gfull",$/;"	s	array:0.arguments
1	compile_commands.json	/^   "-gfull",$/;"	s	array:1.arguments
1	compile_commands.json	/^   "-gfull",$/;"	s	array:2.arguments
1	compile_commands.json	/^   "-gfull",$/;"	s	array:3.arguments
1	compile_commands.json	/^   "-gfull",$/;"	s	array:4.arguments
1	compile_commands.json	/^ {$/;"	o
10	compile_commands.json	/^   "codegen.o",$/;"	s	array:1.arguments
10	compile_commands.json	/^   "corefn.o",$/;"	s	array:3.arguments
10	compile_commands.json	/^   "main.o",$/;"	s	array:2.arguments
10	compile_commands.json	/^   "native.o",$/;"	s	array:4.arguments
10	compile_commands.json	/^   "parser.o",$/;"	s	array:0.arguments
11	compile_commands.json	/^   "codegen.cpp"$/;"	s	array:1.arguments
11	compile_commands.json	/^   "corefn.cpp"$/;"	s	array:3.arguments
11	compile_commands.json	/^   "main.cpp"$/;"	s	array:2.arguments
11	compile_commands.json	/^   "native.cpp"$/;"	s	array:4.arguments
11	compile_commands.json	/^   "parser.cpp"$/;"	s	array:0.arguments
2	compile_commands.json	/^   "-c",$/;"	s	array:0.arguments
2	compile_commands.json	/^   "-c",$/;"	s	array:1.arguments
2	compile_commands.json	/^   "-c",$/;"	s	array:2.arguments
2	compile_commands.json	/^   "-c",$/;"	s	array:3.arguments
2	compile_commands.json	/^   "-c",$/;"	s	array:4.arguments
2	compile_commands.json	/^ {$/;"	o
3	compile_commands.json	/^   "-I\/usr\/include",$/;"	s	array:0.arguments
3	compile_commands.json	/^   "-I\/usr\/include",$/;"	s	array:1.arguments
3	compile_commands.json	/^   "-I\/usr\/include",$/;"	s	array:2.arguments
3	compile_commands.json	/^   "-I\/usr\/include",$/;"	s	array:3.arguments
3	compile_commands.json	/^   "-I\/usr\/include",$/;"	s	array:4.arguments
3	compile_commands.json	/^ {$/;"	o
4	compile_commands.json	/^   "-D_GNU_SOURCE",$/;"	s	array:0.arguments
4	compile_commands.json	/^   "-D_GNU_SOURCE",$/;"	s	array:1.arguments
4	compile_commands.json	/^   "-D_GNU_SOURCE",$/;"	s	array:2.arguments
4	compile_commands.json	/^   "-D_GNU_SOURCE",$/;"	s	array:3.arguments
4	compile_commands.json	/^   "-D_GNU_SOURCE",$/;"	s	array:4.arguments
4	compile_commands.json	/^ {$/;"	o
5	compile_commands.json	/^   "-D__STDC_CONSTANT_MACROS",$/;"	s	array:0.arguments
5	compile_commands.json	/^   "-D__STDC_CONSTANT_MACROS",$/;"	s	array:1.arguments
5	compile_commands.json	/^   "-D__STDC_CONSTANT_MACROS",$/;"	s	array:2.arguments
5	compile_commands.json	/^   "-D__STDC_CONSTANT_MACROS",$/;"	s	array:3.arguments
5	compile_commands.json	/^   "-D__STDC_CONSTANT_MACROS",$/;"	s	array:4.arguments
6	compile_commands.json	/^   "-D__STDC_FORMAT_MACROS",$/;"	s	array:0.arguments
6	compile_commands.json	/^   "-D__STDC_FORMAT_MACROS",$/;"	s	array:1.arguments
6	compile_commands.json	/^   "-D__STDC_FORMAT_MACROS",$/;"	s	array:2.arguments
6	compile_commands.json	/^   "-D__STDC_FORMAT_MACROS",$/;"	s	array:3.arguments
6	compile_commands.json	/^   "-D__STDC_FORMAT_MACROS",$/;"	s	array:4.arguments
7	compile_commands.json	/^   "-D__STDC_LIMIT_MACROS",$/;"	s	array:0.arguments
7	compile_commands.json	/^   "-D__STDC_LIMIT_MACROS",$/;"	s	array:1.arguments
7	compile_commands.json	/^   "-D__STDC_LIMIT_MACROS",$/;"	s	array:2.arguments
7	compile_commands.json	/^   "-D__STDC_LIMIT_MACROS",$/;"	s	array:3.arguments
7	compile_commands.json	/^   "-D__STDC_LIMIT_MACROS",$/;"	s	array:4.arguments
8	compile_commands.json	/^   "-std=c++20",$/;"	s	array:0.arguments
8	compile_commands.json	/^   "-std=c++20",$/;"	s	array:1.arguments
8	compile_commands.json	/^   "-std=c++20",$/;"	s	array:2.arguments
8	compile_commands.json	/^   "-std=c++20",$/;"	s	array:3.arguments
8	compile_commands.json	/^   "-std=c++20",$/;"	s	array:4.arguments
9	compile_commands.json	/^   "-o",$/;"	s	array:0.arguments
9	compile_commands.json	/^   "-o",$/;"	s	array:1.arguments
9	compile_commands.json	/^   "-o",$/;"	s	array:2.arguments
9	compile_commands.json	/^   "-o",$/;"	s	array:3.arguments
9	compile_commands.json	/^   "-o",$/;"	s	array:4.arguments
CPPFLAGS	Makefile	/^CPPFLAGS = `$(LLVMCONFIG) --cppflags` -std=c++20$/;"	m
CodeGenBlock	codegen.h	/^class CodeGenBlock {$/;"	c
CodeGenContext	codegen.h	/^    CodeGenContext() { module = new Module("main", MyContext); }$/;"	f	class:CodeGenContext
CodeGenContext	codegen.h	/^class CodeGenContext {$/;"	c
Define	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
EXIT_SUCCESS	parser.cpp	/^#      define EXIT_SUCCESS /;"	d	file:
EXIT_SUCCESS	parser.cpp	/^#    define EXIT_SUCCESS /;"	d	file:
ExpressionList	node.h	/^typedef std::vector<NExpression*> ExpressionList;$/;"	t	typeref:typename:std::vector<NExpression * >
LDFLAGS	Makefile	/^LDFLAGS = `$(LLVMCONFIG) --ldflags` -lpthread -ldl -lz -lncurses -rdynamic$/;"	m
LIBS	Makefile	/^LIBS = `$(LLVMCONFIG) --libs`$/;"	m
LLVMCONFIG	Makefile	/^LLVMCONFIG = llvm-config$/;"	m
MyContext	codegen.h	/^static LLVMContext MyContext;$/;"	v	typeref:typename:LLVMContext
NAssignment	node.h	/^	NAssignment(NIdentifier& lhs, NExpression& rhs) : $/;"	f	class:NAssignment
NAssignment	node.h	/^class NAssignment : public NExpression {$/;"	c
NBinaryOperator	node.h	/^	NBinaryOperator(NExpression& lhs, int op, NExpression& rhs) :$/;"	f	class:NBinaryOperator
NBinaryOperator	node.h	/^class NBinaryOperator : public NExpression {$/;"	c
NBlock	node.h	/^	NBlock() { }$/;"	f	class:NBlock
NBlock	node.h	/^class NBlock : public NExpression {$/;"	c
NDouble	node.h	/^	NDouble(double value) : value(value) { }$/;"	f	class:NDouble
NDouble	node.h	/^class NDouble : public NExpression {$/;"	c
NExpression	node.h	/^class NExpression : public Node {$/;"	c
NExpressionStatement	node.h	/^	NExpressionStatement(NExpression& expression) : $/;"	f	class:NExpressionStatement
NExpressionStatement	node.h	/^class NExpressionStatement : public NStatement {$/;"	c
NExternDeclaration	node.h	/^    NExternDeclaration(const NIdentifier& type, const NIdentifier& id,$/;"	f	class:NExternDeclaration
NExternDeclaration	node.h	/^class NExternDeclaration : public NStatement {$/;"	c
NFunctionDeclaration	node.h	/^	NFunctionDeclaration(const NIdentifier& type, const NIdentifier& id, $/;"	f	class:NFunctionDeclaration
NFunctionDeclaration	node.h	/^class NFunctionDeclaration : public NStatement {$/;"	c
NIdentifier	node.h	/^	NIdentifier(const std::string& name) : name(name) { }$/;"	f	class:NIdentifier
NIdentifier	node.h	/^class NIdentifier : public NExpression {$/;"	c
NInteger	node.h	/^	NInteger(long long value) : value(value) { }$/;"	f	class:NInteger
NInteger	node.h	/^class NInteger : public NExpression {$/;"	c
NMethodCall	node.h	/^	NMethodCall(const NIdentifier& id) : id(id) { }$/;"	f	class:NMethodCall
NMethodCall	node.h	/^	NMethodCall(const NIdentifier& id, ExpressionList& arguments) :$/;"	f	class:NMethodCall
NMethodCall	node.h	/^class NMethodCall : public NExpression {$/;"	c
NReturnStatement	node.h	/^	NReturnStatement(NExpression& expression) : $/;"	f	class:NReturnStatement
NReturnStatement	node.h	/^class NReturnStatement : public NStatement {$/;"	c
NStatement	node.h	/^class NStatement : public Node {$/;"	c
NVariableDeclaration	node.h	/^	NVariableDeclaration(const NIdentifier& type, NIdentifier& id) :$/;"	f	class:NVariableDeclaration
NVariableDeclaration	node.h	/^	NVariableDeclaration(const NIdentifier& type, NIdentifier& id, NExpression *assignmentExpr) :$/;"	f	class:NVariableDeclaration
NVariableDeclaration	node.h	/^class NVariableDeclaration : public NStatement {$/;"	c
Node	node.h	/^class Node {$/;"	c
OBJS	Makefile	/^OBJS = parser.o  \\$/;"	m
StatementList	node.h	/^typedef std::vector<NStatement*> StatementList;$/;"	t	typeref:typename:std::vector<NStatement * >
TCEQ	parser.hpp	/^    TCEQ = 261,                    \/* TCEQ  *\/$/;"	e	enum:yytokentype
TCEQ	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCGE	parser.hpp	/^    TCGE = 266,                    \/* TCGE  *\/$/;"	e	enum:yytokentype
TCGE	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCGT	parser.hpp	/^    TCGT = 265,                    \/* TCGT  *\/$/;"	e	enum:yytokentype
TCGT	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCLE	parser.hpp	/^    TCLE = 264,                    \/* TCLE  *\/$/;"	e	enum:yytokentype
TCLE	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCLT	parser.hpp	/^    TCLT = 263,                    \/* TCLT  *\/$/;"	e	enum:yytokentype
TCLT	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCNE	parser.hpp	/^    TCNE = 262,                    \/* TCNE  *\/$/;"	e	enum:yytokentype
TCNE	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TCOMMA	parser.hpp	/^    TCOMMA = 272,                  \/* TCOMMA  *\/$/;"	e	enum:yytokentype
TCOMMA	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
TDIV	parser.hpp	/^    TDIV = 277,                    \/* TDIV  *\/$/;"	e	enum:yytokentype
TDIV	parser.y	/^%token <token> TPLUS TMINUS TMUL TDIV$/;"	t	typeref:typename:token
TDOT	parser.hpp	/^    TDOT = 273,                    \/* TDOT  *\/$/;"	e	enum:yytokentype
TDOT	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
TDOUBLE	parser.hpp	/^    TDOUBLE = 260,                 \/* TDOUBLE  *\/$/;"	e	enum:yytokentype
TDOUBLE	parser.y	/^%token <string> TIDENTIFIER TINTEGER TDOUBLE$/;"	t	typeref:typename:string
TEQUAL	parser.hpp	/^    TEQUAL = 267,                  \/* TEQUAL  *\/$/;"	e	enum:yytokentype
TEQUAL	parser.y	/^%token <token> TCEQ TCNE TCLT TCLE TCGT TCGE TEQUAL$/;"	t	typeref:typename:token
TEXTERN	parser.hpp	/^    TEXTERN = 279                  \/* TEXTERN  *\/$/;"	e	enum:yytokentype
TEXTERN	parser.y	/^%token <token> TRETURN TEXTERN$/;"	t	typeref:typename:token
TIDENTIFIER	parser.hpp	/^    TIDENTIFIER = 258,             \/* TIDENTIFIER  *\/$/;"	e	enum:yytokentype
TIDENTIFIER	parser.y	/^%token <string> TIDENTIFIER TINTEGER TDOUBLE$/;"	t	typeref:typename:string
TINTEGER	parser.hpp	/^    TINTEGER = 259,                \/* TINTEGER  *\/$/;"	e	enum:yytokentype
TINTEGER	parser.y	/^%token <string> TIDENTIFIER TINTEGER TDOUBLE$/;"	t	typeref:typename:string
TLBRACE	parser.hpp	/^    TLBRACE = 270,                 \/* TLBRACE  *\/$/;"	e	enum:yytokentype
TLBRACE	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
TLPAREN	parser.hpp	/^    TLPAREN = 268,                 \/* TLPAREN  *\/$/;"	e	enum:yytokentype
TLPAREN	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
TMINUS	parser.hpp	/^    TMINUS = 275,                  \/* TMINUS  *\/$/;"	e	enum:yytokentype
TMINUS	parser.y	/^%token <token> TPLUS TMINUS TMUL TDIV$/;"	t	typeref:typename:token
TMUL	parser.hpp	/^    TMUL = 276,                    \/* TMUL  *\/$/;"	e	enum:yytokentype
TMUL	parser.y	/^%token <token> TPLUS TMINUS TMUL TDIV$/;"	t	typeref:typename:token
TPLUS	parser.hpp	/^    TPLUS = 274,                   \/* TPLUS  *\/$/;"	e	enum:yytokentype
TPLUS	parser.y	/^%token <token> TPLUS TMINUS TMUL TDIV$/;"	t	typeref:typename:token
TRBRACE	parser.hpp	/^    TRBRACE = 271,                 \/* TRBRACE  *\/$/;"	e	enum:yytokentype
TRBRACE	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
TRETURN	parser.hpp	/^    TRETURN = 278,                 \/* TRETURN  *\/$/;"	e	enum:yytokentype
TRETURN	parser.y	/^%token <token> TRETURN TEXTERN$/;"	t	typeref:typename:token
TRPAREN	parser.hpp	/^    TRPAREN = 269,                 \/* TRPAREN  *\/$/;"	e	enum:yytokentype
TRPAREN	parser.y	/^%token <token> TLPAREN TRPAREN TLBRACE TRBRACE TCOMMA TDOT$/;"	t	typeref:typename:token
The	parser.y	/^   The types refer to the %union declaration above. Ex: when$/;"	t	typeref:typename:token
UINT_LEAST16_MAX	parser.cpp	/^# define UINT_LEAST16_MAX /;"	d	file:
UINT_LEAST8_MAX	parser.cpp	/^# define UINT_LEAST8_MAX /;"	d	file:
VariableList	node.h	/^typedef std::vector<NVariableDeclaration*> VariableList;$/;"	t	typeref:typename:std::vector<NVariableDeclaration * >
YYABORT	parser.cpp	/^#define YYABORT /;"	d	file:
YYACCEPT	parser.cpp	/^#define YYACCEPT /;"	d	file:
YYBACKUP	parser.cpp	/^#define YYBACKUP(/;"	d	file:
YYBISON	parser.cpp	/^#define YYBISON /;"	d	file:
YYBISON_VERSION	parser.cpp	/^#define YYBISON_VERSION /;"	d	file:
YYCOPY	parser.cpp	/^#   define YYCOPY(/;"	d	file:
YYCOPY_NEEDED	parser.cpp	/^# define YYCOPY_NEEDED /;"	d	file:
YYDEBUG	parser.hpp	/^# define YYDEBUG /;"	d
YYDPRINTF	parser.cpp	/^# define YYDPRINTF(/;"	d	file:
YYEMPTY	parser.hpp	/^    YYEMPTY = -2,$/;"	e	enum:yytokentype
YYENOMEM	parser.cpp	/^enum { YYENOMEM = -2 };$/;"	e	enum:__anondaf124630103	file:
YYEOF	parser.hpp	/^    YYEOF = 0,                     \/* "end of file"  *\/$/;"	e	enum:yytokentype
YYERRCODE	parser.cpp	/^#define YYERRCODE /;"	d	file:
YYERROR	parser.cpp	/^#define YYERROR /;"	d	file:
YYFINAL	parser.cpp	/^#define YYFINAL /;"	d	file:
YYFPRINTF	parser.cpp	/^#  define YYFPRINTF /;"	d	file:
YYFREE	parser.cpp	/^#   define YYFREE /;"	d	file:
YYINITDEPTH	parser.cpp	/^# define YYINITDEPTH /;"	d	file:
YYLAST	parser.cpp	/^#define YYLAST /;"	d	file:
YYMALLOC	parser.cpp	/^#   define YYMALLOC /;"	d	file:
YYMAXDEPTH	parser.cpp	/^# define YYMAXDEPTH /;"	d	file:
YYMAXUTOK	parser.cpp	/^#define YYMAXUTOK /;"	d	file:
YYNNTS	parser.cpp	/^#define YYNNTS /;"	d	file:
YYNOMEM	parser.cpp	/^#define YYNOMEM /;"	d	file:
YYNRULES	parser.cpp	/^#define YYNRULES /;"	d	file:
YYNSTATES	parser.cpp	/^#define YYNSTATES /;"	d	file:
YYNTOKENS	parser.cpp	/^#define YYNTOKENS /;"	d	file:
YYPACT_NINF	parser.cpp	/^#define YYPACT_NINF /;"	d	file:
YYPOPSTACK	parser.cpp	/^#define YYPOPSTACK(/;"	d	file:
YYPTRDIFF_MAXIMUM	parser.cpp	/^#  define YYPTRDIFF_MAXIMUM /;"	d	file:
YYPTRDIFF_T	parser.cpp	/^#  define YYPTRDIFF_T /;"	d	file:
YYPULL	parser.cpp	/^#define YYPULL /;"	d	file:
YYPURE	parser.cpp	/^#define YYPURE /;"	d	file:
YYPUSH	parser.cpp	/^#define YYPUSH /;"	d	file:
YYRECOVERING	parser.cpp	/^#define YYRECOVERING(/;"	d	file:
YYSIZEOF	parser.cpp	/^#define YYSIZEOF(/;"	d	file:
YYSIZE_MAXIMUM	parser.cpp	/^#define YYSIZE_MAXIMUM /;"	d	file:
YYSIZE_T	parser.cpp	/^#  define YYSIZE_T /;"	d	file:
YYSKELETON_NAME	parser.cpp	/^#define YYSKELETON_NAME /;"	d	file:
YYSTACK_ALLOC	parser.cpp	/^#    define YYSTACK_ALLOC /;"	d	file:
YYSTACK_ALLOC	parser.cpp	/^#  define YYSTACK_ALLOC /;"	d	file:
YYSTACK_ALLOC_MAXIMUM	parser.cpp	/^#   define YYSTACK_ALLOC_MAXIMUM /;"	d	file:
YYSTACK_BYTES	parser.cpp	/^# define YYSTACK_BYTES(/;"	d	file:
YYSTACK_FREE	parser.cpp	/^#  define YYSTACK_FREE /;"	d	file:
YYSTACK_FREE	parser.cpp	/^#  define YYSTACK_FREE(/;"	d	file:
YYSTACK_GAP_MAXIMUM	parser.cpp	/^# define YYSTACK_GAP_MAXIMUM /;"	d	file:
YYSTACK_RELOCATE	parser.cpp	/^# define YYSTACK_RELOCATE(/;"	d	file:
YYSTYPE	parser.hpp	/^typedef union YYSTYPE YYSTYPE;$/;"	t	typeref:union:YYSTYPE
YYSTYPE	parser.hpp	/^union YYSTYPE$/;"	u
YYSTYPE_IS_DECLARED	parser.hpp	/^# define YYSTYPE_IS_DECLARED /;"	d
YYSTYPE_IS_TRIVIAL	parser.hpp	/^# define YYSTYPE_IS_TRIVIAL /;"	d
YYSYMBOL_TCEQ	parser.cpp	/^  YYSYMBOL_TCEQ = 6,                       \/* TCEQ  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCGE	parser.cpp	/^  YYSYMBOL_TCGE = 11,                      \/* TCGE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCGT	parser.cpp	/^  YYSYMBOL_TCGT = 10,                      \/* TCGT  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCLE	parser.cpp	/^  YYSYMBOL_TCLE = 9,                       \/* TCLE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCLT	parser.cpp	/^  YYSYMBOL_TCLT = 8,                       \/* TCLT  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCNE	parser.cpp	/^  YYSYMBOL_TCNE = 7,                       \/* TCNE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TCOMMA	parser.cpp	/^  YYSYMBOL_TCOMMA = 17,                    \/* TCOMMA  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TDIV	parser.cpp	/^  YYSYMBOL_TDIV = 22,                      \/* TDIV  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TDOT	parser.cpp	/^  YYSYMBOL_TDOT = 18,                      \/* TDOT  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TDOUBLE	parser.cpp	/^  YYSYMBOL_TDOUBLE = 5,                    \/* TDOUBLE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TEQUAL	parser.cpp	/^  YYSYMBOL_TEQUAL = 12,                    \/* TEQUAL  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TEXTERN	parser.cpp	/^  YYSYMBOL_TEXTERN = 24,                   \/* TEXTERN  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TIDENTIFIER	parser.cpp	/^  YYSYMBOL_TIDENTIFIER = 3,                \/* TIDENTIFIER  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TINTEGER	parser.cpp	/^  YYSYMBOL_TINTEGER = 4,                   \/* TINTEGER  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TLBRACE	parser.cpp	/^  YYSYMBOL_TLBRACE = 15,                   \/* TLBRACE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TLPAREN	parser.cpp	/^  YYSYMBOL_TLPAREN = 13,                   \/* TLPAREN  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TMINUS	parser.cpp	/^  YYSYMBOL_TMINUS = 20,                    \/* TMINUS  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TMUL	parser.cpp	/^  YYSYMBOL_TMUL = 21,                      \/* TMUL  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TPLUS	parser.cpp	/^  YYSYMBOL_TPLUS = 19,                     \/* TPLUS  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TRBRACE	parser.cpp	/^  YYSYMBOL_TRBRACE = 16,                   \/* TRBRACE  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TRETURN	parser.cpp	/^  YYSYMBOL_TRETURN = 23,                   \/* TRETURN  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_TRPAREN	parser.cpp	/^  YYSYMBOL_TRPAREN = 14,                   \/* TRPAREN  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_YYACCEPT	parser.cpp	/^  YYSYMBOL_YYACCEPT = 25,                  \/* $accept  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_YYEMPTY	parser.cpp	/^  YYSYMBOL_YYEMPTY = -2,$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_YYEOF	parser.cpp	/^  YYSYMBOL_YYEOF = 0,                      \/* "end of file"  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_YYUNDEF	parser.cpp	/^  YYSYMBOL_YYUNDEF = 2,                    \/* "invalid token"  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_YYerror	parser.cpp	/^  YYSYMBOL_YYerror = 1,                    \/* error  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_block	parser.cpp	/^  YYSYMBOL_block = 29,                     \/* block  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_call_args	parser.cpp	/^  YYSYMBOL_call_args = 37,                 \/* call_args  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_comparison	parser.cpp	/^  YYSYMBOL_comparison = 38                 \/* comparison  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_expr	parser.cpp	/^  YYSYMBOL_expr = 36,                      \/* expr  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_extern_decl	parser.cpp	/^  YYSYMBOL_extern_decl = 31,               \/* extern_decl  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_func_decl	parser.cpp	/^  YYSYMBOL_func_decl = 32,                 \/* func_decl  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_func_decl_args	parser.cpp	/^  YYSYMBOL_func_decl_args = 33,            \/* func_decl_args  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_ident	parser.cpp	/^  YYSYMBOL_ident = 34,                     \/* ident  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_numeric	parser.cpp	/^  YYSYMBOL_numeric = 35,                   \/* numeric  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_program	parser.cpp	/^  YYSYMBOL_program = 26,                   \/* program  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_stmt	parser.cpp	/^  YYSYMBOL_stmt = 28,                      \/* stmt  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_stmts	parser.cpp	/^  YYSYMBOL_stmts = 27,                     \/* stmts  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYSYMBOL_var_decl	parser.cpp	/^  YYSYMBOL_var_decl = 30,                  \/* var_decl  *\/$/;"	e	enum:yysymbol_kind_t	file:
YYTABLE_NINF	parser.cpp	/^#define YYTABLE_NINF /;"	d	file:
YYTOKENTYPE	parser.hpp	/^# define YYTOKENTYPE$/;"	d
YYTRANSLATE	parser.cpp	/^#define YYTRANSLATE(/;"	d	file:
YYUNDEF	parser.hpp	/^    YYUNDEF = 257,                 \/* "invalid token"  *\/$/;"	e	enum:yytokentype
YY_	parser.cpp	/^#   define YY_(/;"	d	file:
YY_	parser.cpp	/^#  define YY_(/;"	d	file:
YY_ACCESSING_SYMBOL	parser.cpp	/^#define YY_ACCESSING_SYMBOL(/;"	d	file:
YY_ASSERT	parser.cpp	/^#define YY_ASSERT(/;"	d	file:
YY_ATTRIBUTE_PURE	parser.cpp	/^#  define YY_ATTRIBUTE_PURE /;"	d	file:
YY_ATTRIBUTE_PURE	parser.cpp	/^#  define YY_ATTRIBUTE_PURE$/;"	d	file:
YY_ATTRIBUTE_UNUSED	parser.cpp	/^#  define YY_ATTRIBUTE_UNUSED /;"	d	file:
YY_ATTRIBUTE_UNUSED	parser.cpp	/^#  define YY_ATTRIBUTE_UNUSED$/;"	d	file:
YY_CAST	parser.cpp	/^#   define YY_CAST(/;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parser.cpp	/^#  define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN /;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN	parser.cpp	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN$/;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_END	parser.cpp	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_END /;"	d	file:
YY_IGNORE_MAYBE_UNINITIALIZED_END	parser.cpp	/^# define YY_IGNORE_MAYBE_UNINITIALIZED_END$/;"	d	file:
YY_IGNORE_USELESS_CAST_BEGIN	parser.cpp	/^# define YY_IGNORE_USELESS_CAST_BEGIN /;"	d	file:
YY_IGNORE_USELESS_CAST_BEGIN	parser.cpp	/^# define YY_IGNORE_USELESS_CAST_BEGIN$/;"	d	file:
YY_IGNORE_USELESS_CAST_END	parser.cpp	/^# define YY_IGNORE_USELESS_CAST_END /;"	d	file:
YY_IGNORE_USELESS_CAST_END	parser.cpp	/^# define YY_IGNORE_USELESS_CAST_END$/;"	d	file:
YY_INITIAL_VALUE	parser.cpp	/^# define YY_INITIAL_VALUE(/;"	d	file:
YY_NULLPTR	parser.cpp	/^#    define YY_NULLPTR /;"	d	file:
YY_NULLPTR	parser.cpp	/^#   define YY_NULLPTR /;"	d	file:
YY_REDUCE_PRINT	parser.cpp	/^# define YY_REDUCE_PRINT(/;"	d	file:
YY_REINTERPRET_CAST	parser.cpp	/^#   define YY_REINTERPRET_CAST(/;"	d	file:
YY_STACK_PRINT	parser.cpp	/^# define YY_STACK_PRINT(/;"	d	file:
YY_STDINT_H	parser.cpp	/^#  define YY_STDINT_H$/;"	d	file:
YY_SYMBOL_PRINT	parser.cpp	/^# define YY_SYMBOL_PRINT(/;"	d	file:
YY_USE	parser.cpp	/^# define YY_USE(/;"	d	file:
YY_YY_PARSER_HPP_INCLUDED	parser.hpp	/^# define YY_YY_PARSER_HPP_INCLUDED$/;"	d
YYerror	parser.hpp	/^    YYerror = 256,                 \/* error  *\/$/;"	e	enum:yytokentype
__anondaf124630103	parser.cpp	/^enum { YYENOMEM = -2 };$/;"	g	file:
all	Makefile	/^all: parser$/;"	t
alloca	parser.cpp	/^#    define alloca _alloca$/;"	d	file:
arguments	compile_commands.json	/^  "arguments": [$/;"	a	object:0
arguments	compile_commands.json	/^  "arguments": [$/;"	a	object:1
arguments	compile_commands.json	/^  "arguments": [$/;"	a	object:2
arguments	compile_commands.json	/^  "arguments": [$/;"	a	object:3
arguments	compile_commands.json	/^  "arguments": [$/;"	a	object:4
arguments	node.h	/^	ExpressionList arguments;$/;"	m	class:NMethodCall	typeref:typename:ExpressionList
arguments	node.h	/^	VariableList arguments;$/;"	m	class:NFunctionDeclaration	typeref:typename:VariableList
arguments	node.h	/^    VariableList arguments;$/;"	m	class:NExternDeclaration	typeref:typename:VariableList
assignmentExpr	node.h	/^	NExpression *assignmentExpr;$/;"	m	class:NVariableDeclaration	typeref:typename:NExpression *
block	codegen.h	/^    BasicBlock *block;$/;"	m	class:CodeGenBlock	typeref:typename:BasicBlock *
block	node.h	/^	NBlock& block;$/;"	m	class:NFunctionDeclaration	typeref:typename:NBlock &
block	parser.hpp	/^	NBlock *block;$/;"	m	union:YYSTYPE	typeref:typename:NBlock *
blocks	codegen.h	/^    std::stack<CodeGenBlock *> blocks;$/;"	m	class:CodeGenContext	typeref:typename:std::stack<CodeGenBlock * >
clean	Makefile	/^clean:$/;"	t
codeGen	codegen.cpp	/^Value* NAssignment::codeGen(CodeGenContext& context)$/;"	f	class:NAssignment	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NBinaryOperator::codeGen(CodeGenContext& context)$/;"	f	class:NBinaryOperator	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NBlock::codeGen(CodeGenContext& context)$/;"	f	class:NBlock	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NDouble::codeGen(CodeGenContext& context)$/;"	f	class:NDouble	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NExpressionStatement::codeGen(CodeGenContext& context)$/;"	f	class:NExpressionStatement	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NExternDeclaration::codeGen(CodeGenContext& context)$/;"	f	class:NExternDeclaration	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NFunctionDeclaration::codeGen(CodeGenContext& context)$/;"	f	class:NFunctionDeclaration	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NIdentifier::codeGen(CodeGenContext& context)$/;"	f	class:NIdentifier	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NInteger::codeGen(CodeGenContext& context)$/;"	f	class:NInteger	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NMethodCall::codeGen(CodeGenContext& context)$/;"	f	class:NMethodCall	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NReturnStatement::codeGen(CodeGenContext& context)$/;"	f	class:NReturnStatement	typeref:typename:Value *
codeGen	codegen.cpp	/^Value* NVariableDeclaration::codeGen(CodeGenContext& context)$/;"	f	class:NVariableDeclaration	typeref:typename:Value *
codeGen	node.h	/^	virtual llvm::Value* codeGen(CodeGenContext& context) { return NULL; }$/;"	f	class:Node	typeref:typename:llvm::Value *
createCoreFunctions	corefn.cpp	/^void createCoreFunctions(CodeGenContext& context){$/;"	f	typeref:typename:void
createEchoFunction	corefn.cpp	/^void createEchoFunction(CodeGenContext& context, llvm::Function* printfFn)$/;"	f	typeref:typename:void
createPrintfFunction	corefn.cpp	/^llvm::Function* createPrintfFunction(CodeGenContext& context)$/;"	f	typeref:typename:llvm::Function *
currentBlock	codegen.h	/^    BasicBlock *currentBlock() { return blocks.top()->block; }$/;"	f	class:CodeGenContext	typeref:typename:BasicBlock *
debug	README.md	/^## debug$/;"	s	chapter:my_toy_compiler
directory	compile_commands.json	/^  "directory": "\/home\/sgj\/codes\/fy\/my_toy_compiler",$/;"	s	object:0
directory	compile_commands.json	/^  "directory": "\/home\/sgj\/codes\/fy\/my_toy_compiler",$/;"	s	object:1
directory	compile_commands.json	/^  "directory": "\/home\/sgj\/codes\/fy\/my_toy_compiler",$/;"	s	object:2
directory	compile_commands.json	/^  "directory": "\/home\/sgj\/codes\/fy\/my_toy_compiler",$/;"	s	object:3
directory	compile_commands.json	/^  "directory": "\/home\/sgj\/codes\/fy\/my_toy_compiler",$/;"	s	object:4
expr	parser.hpp	/^	NExpression *expr;$/;"	m	union:YYSTYPE	typeref:typename:NExpression *
expression	node.h	/^	NExpression& expression;$/;"	m	class:NExpressionStatement	typeref:typename:NExpression &
expression	node.h	/^	NExpression& expression;$/;"	m	class:NReturnStatement	typeref:typename:NExpression &
exprvec	parser.hpp	/^	std::vector<NExpression*> *exprvec;$/;"	m	union:YYSTYPE	typeref:typename:std::vector<NExpression * > *
file	compile_commands.json	/^  "file": "codegen.cpp"$/;"	s	object:1
file	compile_commands.json	/^  "file": "corefn.cpp"$/;"	s	object:3
file	compile_commands.json	/^  "file": "main.cpp"$/;"	s	object:2
file	compile_commands.json	/^  "file": "native.cpp"$/;"	s	object:4
file	compile_commands.json	/^  "file": "parser.cpp"$/;"	s	object:0
generateCode	codegen.cpp	/^void CodeGenContext::generateCode(NBlock& root)$/;"	f	class:CodeGenContext	typeref:typename:void
getCurrentReturnValue	codegen.h	/^    Value* getCurrentReturnValue() { return blocks.top()->returnValue; }$/;"	f	class:CodeGenContext	typeref:typename:Value *
id	node.h	/^	NIdentifier& id;$/;"	m	class:NVariableDeclaration	typeref:typename:NIdentifier &
id	node.h	/^	const NIdentifier& id;$/;"	m	class:NFunctionDeclaration	typeref:typename:const NIdentifier &
id	node.h	/^	const NIdentifier& id;$/;"	m	class:NMethodCall	typeref:typename:const NIdentifier &
id	node.h	/^    const NIdentifier& id;$/;"	m	class:NExternDeclaration	typeref:typename:const NIdentifier &
ident	parser.hpp	/^	NIdentifier *ident;$/;"	m	union:YYSTYPE	typeref:typename:NIdentifier *
lhs	node.h	/^	NExpression& lhs;$/;"	m	class:NBinaryOperator	typeref:typename:NExpression &
lhs	node.h	/^	NIdentifier& lhs;$/;"	m	class:NAssignment	typeref:typename:NIdentifier &
llvm 15 compatibility	README.md	/^## llvm 15 compatibility$/;"	s	chapter:my_toy_compiler
locals	codegen.h	/^    std::map<std::string, Value*> locals;$/;"	m	class:CodeGenBlock	typeref:typename:std::map<std::string,Value * >
locals	codegen.h	/^    std::map<std::string, Value*>& locals() { return blocks.top()->locals; }$/;"	f	class:CodeGenContext	typeref:typename:std::map<std::string,Value * > &
main	main.cpp	/^int main(int argc, char **argv)$/;"	f	typeref:typename:int
mainFunction	codegen.h	/^    Function *mainFunction;$/;"	m	class:CodeGenContext	typeref:typename:Function *
module	codegen.h	/^    Module *module;$/;"	m	class:CodeGenContext	typeref:typename:Module *
my_toy_compiler	README.md	/^# my_toy_compiler$/;"	c
name	node.h	/^	std::string name;$/;"	m	class:NIdentifier	typeref:typename:std::string
node	parser.hpp	/^	Node *node;$/;"	m	union:YYSTYPE	typeref:typename:Node *
node	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
nonterminal	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
of	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
op	node.h	/^	int op;$/;"	m	class:NBinaryOperator	typeref:typename:int
open_file	main.cpp	/^void open_file(const char* filename) {$/;"	f	typeref:typename:void
our	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
parser	Makefile	/^parser: $(OBJS)$/;"	t
parser.cpp	Makefile	/^parser.cpp: parser.y$/;"	t
parser.hpp	Makefile	/^parser.hpp: parser.cpp$/;"	t
popBlock	codegen.h	/^    void popBlock() { CodeGenBlock *top = blocks.top(); blocks.pop(); delete top; }$/;"	f	class:CodeGenContext	typeref:typename:void
printi	native.cpp	/^void printi(long long val)$/;"	f	typeref:typename:void
programBlock	parser.cpp	/^	NBlock *programBlock; \/* the top level root node of our final AST *\/$/;"	v	typeref:typename:NBlock *
pushBlock	codegen.h	/^    void pushBlock(BasicBlock *block) { blocks.push(new CodeGenBlock()); blocks.top()->returnVal/;"	f	class:CodeGenContext	typeref:typename:void
refer	parser.y	/^   The types refer to the %union declaration above. Ex: when$/;"	t	typeref:typename:token
represent	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
returnValue	codegen.h	/^    Value *returnValue;$/;"	m	class:CodeGenBlock	typeref:typename:Value *
rhs	node.h	/^	NExpression& rhs;$/;"	m	class:NAssignment	typeref:typename:NExpression &
rhs	node.h	/^	NExpression& rhs;$/;"	m	class:NBinaryOperator	typeref:typename:NExpression &
run	README.md	/^## run $/;"	s	chapter:my_toy_compiler
runCode	codegen.cpp	/^GenericValue CodeGenContext::runCode() {$/;"	f	class:CodeGenContext	typeref:typename:GenericValue
setCurrentReturnValue	codegen.h	/^    void setCurrentReturnValue(Value *value) { blocks.top()->returnValue = value; }$/;"	f	class:CodeGenContext	typeref:typename:void
statements	node.h	/^	StatementList statements;$/;"	m	class:NBlock	typeref:typename:StatementList
stmt	parser.hpp	/^	NStatement *stmt;$/;"	m	union:YYSTYPE	typeref:typename:NStatement *
string	parser.hpp	/^	std::string *string;$/;"	m	union:YYSTYPE	typeref:typename:std::string *
symbols	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
test	Makefile	/^test: parser example.txt$/;"	t
the	parser.y	/^   The types refer to the %union declaration above. Ex: when$/;"	t	typeref:typename:token
the	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
to	parser.y	/^   The types refer to the %union declaration above. Ex: when$/;"	t	typeref:typename:token
token	parser.hpp	/^	int token;$/;"	m	union:YYSTYPE	typeref:typename:int
tokens.cpp	Makefile	/^tokens.cpp: tokens.l parser.hpp$/;"	t
type	node.h	/^	const NIdentifier& type;$/;"	m	class:NFunctionDeclaration	typeref:typename:const NIdentifier &
type	node.h	/^	const NIdentifier& type;$/;"	m	class:NVariableDeclaration	typeref:typename:const NIdentifier &
type	node.h	/^    const NIdentifier& type;$/;"	m	class:NExternDeclaration	typeref:typename:const NIdentifier &
type	parser.y	/^\/* Define the type of node our nonterminal symbols represent.$/;"	t	typeref:typename:token
typeOf	codegen.cpp	/^static Type *typeOf(const NIdentifier& type) $/;"	f	typeref:typename:Type *	file:
types	parser.y	/^   The types refer to the %union declaration above. Ex: when$/;"	t	typeref:typename:token
value	node.h	/^	double value;$/;"	m	class:NDouble	typeref:typename:double
value	node.h	/^	long long value;$/;"	m	class:NInteger	typeref:typename:long long
var_decl	parser.hpp	/^	NVariableDeclaration *var_decl;$/;"	m	union:YYSTYPE	typeref:typename:NVariableDeclaration *
varvec	parser.hpp	/^	std::vector<NVariableDeclaration*> *varvec;$/;"	m	union:YYSTYPE	typeref:typename:std::vector<NVariableDeclaration * > *
yy_reduce_print	parser.cpp	/^yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,$/;"	f	typeref:typename:void	file:
yy_stack_print	parser.cpp	/^yy_stack_print (yy_state_t *yybottom, yy_state_t *yytop)$/;"	f	typeref:typename:void	file:
yy_state_fast_t	parser.cpp	/^typedef int yy_state_fast_t;$/;"	t	typeref:typename:int	file:
yy_state_t	parser.cpp	/^typedef yytype_int8 yy_state_t;$/;"	t	typeref:typename:yytype_int8	file:
yy_symbol_print	parser.cpp	/^yy_symbol_print (FILE *yyo,$/;"	f	typeref:typename:void	file:
yy_symbol_value_print	parser.cpp	/^yy_symbol_value_print (FILE *yyo,$/;"	f	typeref:typename:void	file:
yyalloc	parser.cpp	/^union yyalloc$/;"	u	file:
yychar	parser.cpp	/^int yychar;$/;"	v	typeref:typename:int
yycheck	parser.cpp	/^static const yytype_int8 yycheck[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyclearin	parser.cpp	/^#define yyclearin /;"	d	file:
yydebug	parser.cpp	/^int yydebug;$/;"	v	typeref:typename:int
yydefact	parser.cpp	/^static const yytype_int8 yydefact[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yydefgoto	parser.cpp	/^static const yytype_int8 yydefgoto[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yydestruct	parser.cpp	/^yydestruct (const char *yymsg,$/;"	f	typeref:typename:void	file:
yyerrok	parser.cpp	/^#define yyerrok /;"	d	file:
yyerror	parser.cpp	/^	void yyerror(const char *s) { std::printf("Error: %s\\n", s);std::exit(1); }$/;"	f	typeref:typename:void
yylval	parser.cpp	/^YYSTYPE yylval;$/;"	v	typeref:typename:YYSTYPE
yynerrs	parser.cpp	/^int yynerrs;$/;"	v	typeref:typename:int
yypact	parser.cpp	/^static const yytype_int8 yypact[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yypact_value_is_default	parser.cpp	/^#define yypact_value_is_default(/;"	d	file:
yyparse	parser.cpp	/^yyparse (void)$/;"	f	typeref:typename:int
yypgoto	parser.cpp	/^static const yytype_int8 yypgoto[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyr1	parser.cpp	/^static const yytype_int8 yyr1[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyr2	parser.cpp	/^static const yytype_int8 yyr2[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyrline	parser.cpp	/^static const yytype_int8 yyrline[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yyss_alloc	parser.cpp	/^  yy_state_t yyss_alloc;$/;"	m	union:yyalloc	typeref:typename:yy_state_t	file:
yystos	parser.cpp	/^static const yytype_int8 yystos[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yysymbol_kind_t	parser.cpp	/^enum yysymbol_kind_t$/;"	g	file:
yysymbol_kind_t	parser.cpp	/^typedef enum yysymbol_kind_t yysymbol_kind_t;$/;"	t	typeref:enum:yysymbol_kind_t	file:
yysymbol_name	parser.cpp	/^yysymbol_name (yysymbol_kind_t yysymbol)$/;"	f	typeref:typename:const char *	file:
yytable	parser.cpp	/^static const yytype_int8 yytable[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yytable_value_is_error	parser.cpp	/^#define yytable_value_is_error(/;"	d	file:
yytname	parser.cpp	/^static const char *const yytname[] =$/;"	v	typeref:typename:const char * const[]	file:
yytoken_kind_t	parser.hpp	/^  typedef enum yytokentype yytoken_kind_t;$/;"	t	typeref:enum:yytokentype
yytokentype	parser.hpp	/^  enum yytokentype$/;"	g
yytranslate	parser.cpp	/^static const yytype_int8 yytranslate[] =$/;"	v	typeref:typename:const yytype_int8[]	file:
yytype_int16	parser.cpp	/^typedef __INT_LEAST16_TYPE__ yytype_int16;$/;"	t	typeref:typename:__INT_LEAST16_TYPE__	file:
yytype_int16	parser.cpp	/^typedef int_least16_t yytype_int16;$/;"	t	typeref:typename:int_least16_t	file:
yytype_int16	parser.cpp	/^typedef short yytype_int16;$/;"	t	typeref:typename:short	file:
yytype_int8	parser.cpp	/^typedef __INT_LEAST8_TYPE__ yytype_int8;$/;"	t	typeref:typename:__INT_LEAST8_TYPE__	file:
yytype_int8	parser.cpp	/^typedef int_least8_t yytype_int8;$/;"	t	typeref:typename:int_least8_t	file:
yytype_int8	parser.cpp	/^typedef signed char yytype_int8;$/;"	t	typeref:typename:signed char	file:
yytype_uint16	parser.cpp	/^typedef __UINT_LEAST16_TYPE__ yytype_uint16;$/;"	t	typeref:typename:__UINT_LEAST16_TYPE__	file:
yytype_uint16	parser.cpp	/^typedef int yytype_uint16;$/;"	t	typeref:typename:int	file:
yytype_uint16	parser.cpp	/^typedef uint_least16_t yytype_uint16;$/;"	t	typeref:typename:uint_least16_t	file:
yytype_uint16	parser.cpp	/^typedef unsigned short yytype_uint16;$/;"	t	typeref:typename:unsigned short	file:
yytype_uint8	parser.cpp	/^typedef __UINT_LEAST8_TYPE__ yytype_uint8;$/;"	t	typeref:typename:__UINT_LEAST8_TYPE__	file:
yytype_uint8	parser.cpp	/^typedef short yytype_uint8;$/;"	t	typeref:typename:short	file:
yytype_uint8	parser.cpp	/^typedef uint_least8_t yytype_uint8;$/;"	t	typeref:typename:uint_least8_t	file:
yytype_uint8	parser.cpp	/^typedef unsigned char yytype_uint8;$/;"	t	typeref:typename:unsigned char	file:
yyvs_alloc	parser.cpp	/^  YYSTYPE yyvs_alloc;$/;"	m	union:yyalloc	typeref:typename:YYSTYPE	file:
~Node	node.h	/^	virtual ~Node() {}$/;"	f	class:Node
